# Полезные заметки по работе с GIT
## Настройка окружения и знакомство с командной строкой  
**GIT** - Система контроля версий, которая помогает отслеживать изменения в поекте. Поволяет сохранять изменения локально и возвращаться к предыдущим версиям проекта.  
**GitHub** - Самая популярная платформа для хранения IT-проектов и командной работы над ними.  
**VCS (Version Control System)** - Система контроля версий.  
**SCM (Source Control Management)** - Система управления исходным кодом.  

**Ревизия (Версия)** - Одно из изменений или группа изменений. Содержит в себе инфо о:
- что изменилось;
- кто внёс изменения;
- когда;
- комментарии.

**Основные функции VCS:**
- Хранит историю изменений в виде отдельных ревизий;
- Манипуляция историей: менять порядок ревизий, удалять версии, возвращаться назад в истории;
- Анализ изменения (что?когда?кто?);
- Поддержка парралельной работы нескольких пользователей в т.ч. с одним файлом.

## Установка командной строки для пользователей Windows
Инструкция по установке для пользователей Windows.
- Скачайте **Standalone Installer** для вашей версии Windows c [официального сайта GIT](официального сайта);
- Запустите программу установки. Обратите внимание, куда будет установлен Git. Обычно это: ```C:\Program Files\Git```
- Проверьте, что в списке устанавливаемых программ стоит галочка напротив пункта Git Bash Here — это позволит открывать консоль с Git в любой папке.
- Далее установщик предложит много опций. Для нашего курса достаточно оставить все настройки по умолчанию. Несколько раз нажмите Next, пока не начнётся процесс установки.
- После окончания установки нажмите Finish.

## Первый запуск Git Bash
Запустите программу Git Bash. Сделать это можно двумя способами. Можно ввести название программы в окно поиска на панели задач.
А можно открыть директорию, в которую был установлен Git. Обычно это директория ```C:\Program Files\Git\bin```. Перейдите в ```bin``` и запустите файл ```bash.exe```.
Вместо ```USER_NAME``` будет указано ваше имя пользователя, а вместо ```HOST_NAME``` — имя компьютера. Если вы видите консоль, значит, установка прошла успешно.

## Знакомство с командной строкой
**GUI** (Graphical User Interface) - Графический интерфейс.  
**CLI** (Command Line Interface) - Командная строка / Терминал / Консоль.  

```$ pwd``` - команда показывает рабочую папку (та, в которой вы сейчас находитесь)  
```$ cd имя_папки``` - сменить директорию  !если в названии папки есть пробелы, то нужно использовать кавычки  
```$ cd ~``` - переход в домашнюю директорию  
```$ cd ..``` - возврат на уровень выше  
```$ cd .``` - переход в текущую директорию  
```$ cd имя_папки/имя_папки/``` - переход через несколько директорий 

## Навигация в командной строке  
```$ ls``` - вывести содержимое директории  
```$ ls -a``` - вывести список в котором отображаются скрытые файлы  
```$ ls ~``` - выведет содержимое домашней директории
```$ ls ..``` - выведет содержимое родительской директории

## Операции с папками и файлами: создание, копирование, перемещение  
### Создание файлов и директорий
```$ touch имя_файла``` - создание файла в текущей директории !в имени файла обязательно нужно указывать расширение, к примеру .txt  
```$ touch ~/имя_файла``` - создание файла в домашней директории  
```$ touch ../имя_файла``` - создание файла на папку выше (в родительской директории)  
```$ touch ../../имя_файла``` - создание файла на ДВЕ папки выше  
```$ mkdir имя_директории``` - создание директории в текущей директории  
```$ mkdir ~/имя_директории``` - создание директории в домашней директории  
```$ mkdir ../имя_директории``` - создание директории на папку выше (в родительской директории)  
```$ mkdir -p имя_директории1/имя_директории2/имя_директории3``` - создаyние структуры директорий  

### Копирование файлов
```$ cp что_копируем что_копируем куда_копируем``` - копирование файлов !можно указать несколько файлов  

### Перемещение файлов и папок
```$ mv что_перемещаем что_перемещаем куда_перемещаем``` - перемещение файла/папки !можно указать несколько файлов/папок  

## Операции с папками и файлами: чтение и удаление  
### Чтение файлов
```$ cat имя_файла``` - чтение файла !работает только с текстовыми файлами .txt  

### Удаление файлов и папок  
```$ rm имя_файла``` - удаление файла !удаление не обратимо, файлы не попадают в корзину, а исчезают навсегда!  
```$ rm -r имя_папки``` - удаление папки и всего её содержимого !удаление не обратимо, файлы не попадают в корзину, а исчезают навсегда!  
```$ rmdir имя_папки``` - удаление папки !если в паапке, которую удаляешь, есть файлы, будет ошибка "Directory not empty!"  

## Эффективная работа с командной строкой  
### Выполняйте сразу несколько команд  
```&&``` - выполняет сразу несколько команд
пример: ```mkdir second-project && cd second-project && touch index.html style.css```  

### Вызывайте команды из буфера
```↑``` - обращение к последней введённой команде (нажмите на клавиатуре стрелку вверх) !Если нажать ещё раз, появится предпоследняя команда; ещё раз — предпредпоследняя; и так далее  
```↓``` - чтобы вернуться — например, от предпоследней команды к последней, — нажмите стрелку вниз  

### Используйте автозаполнение
```первый_символ дважды нажать Tab``` - терминал покажет список всех команд, которые начинаются с этих символов.  ```Tab``` автоматически дописывает не только команды, но и пути. Начните печатать имя папки или файла (они должны быть в той же директории) и нажмите ```Tab```. Терминал заполнит имя автоматически. Если этого не происходит, значит, есть несколько файлов или папок, которые начинаются так же. Нажмите ```Tab``` ещё раз, и вы увидите их список. 
```$ cd ~/Tab``` - в консоль выведутся все возможные пути  
```$ cd s:/``` - команда для попадания на конкретный диск

## Установка Git
Если вы пользователь Windows, то Git у вас уже есть. Вы установили его в составе пакета Git for Windows вместе с командной строкой.  
```$ git version``` - если Git установлен правильно, консоль выведет его текущую версию

## Настройка Git
Для настройки Git можно использовать командную строку - запустите Git Bash.  

### Работа с файлом настройки .gitconfig  
Сейчас вы работаете в одиночку, но в дальнейшем вам может понадобиться использовать Git в команде. Чтобы участникам проекта было понятно, кто и какие изменения вносил, нужно представиться и указать имя пользователя ```user.name``` и ```user.email``` адрес электронной почты:  
```$ git config --global user.name "User Namovich" ``` - *# имя или ник нужно написать латиницей и в кавычках*  
```$ git config --global user.email username@yandex.ru``` - *# здесь нужно указать свой настоящий email*  

Все глобальные настройки Git хранит в файле ```.gitconfig``` в домашней директории. Команда запишет в этот файл указанные имя и почту. Чтобы убедиться в этом, нужно вывести содержимое файла конфигурации Git той же командой git config с флагом --list:  
```$ git config --list```   
В ответ командная строка покажет текущие значения настроек:
```user.name=Username```   
```user.email=username@yandex.ru```  

## Инициализируем репозиторий  
### Сделать папку репозиторием — git init  
Чтобы Git начал отслеживать изменения в проекте, папку с файлами этого проекта нужно сделать Git-репозиторием. Для этого следует переместиться в неё и ввести команду ```git init```.  
Также ```git init``` выведет сообщение вида ```Initialized empty Git repository in <*ваша папка с проектом*>/.git/``` (англ. «инициализирован пустой Git-репозиторий в <*ваша папка*>/.git/»). В подпапке ```.git``` Git будет хранить всю служебную информацию.  

### «Разгитить» папку, если что-то пошло не так, — rm -rf .git  
Если вы случайно сделали Git-репозиторием не ту папку, её можно «разгитить». Для этого нужно удалить скрытую подпапку ```.git```.  
```$ cd <папка с репозиторием> # перешли в папку```  
```$ rm -rf .git # удалили подпапку .git```  

```-rf``` - позволяет удалять папки вместе с их содержимым + избавит вас от вопросов вроде «Вы точно хотите удалить этот файл? А этот? И этот тоже?  
Будьте осторожны: в подпапке ```.git``` хранится история изменений. Если удалить ```.git```, то вся история проекта будет стёрта без возможности восстановления — останется только последняя версия файлов.

### Проверить состояние репозитория — git status  
Команда ```git status``` выведет:
- название текущей ветки: ```On branch master``` или ```On branch main```;  
- сообщение о том, что в репозитории ещё нет коммитов: ```No commits yet```;
- сообщение, которое говорит: «чтобы что-нибудь закоммитить (то есть зафиксировать), нужно сначала это создать» — ```nothing to commit (create/copy files and use "git add" to track)```.  

## Добавляем файлы в репозиторий  
### Подготовить файлы к сохранению — git add  
```$ git add --all``` - отслеживание состояния всех файлов в репозитории !команда отслеживает текущее содержимое файла(ов), но не сохраняет его  
```$ git add имя_файла``` - отслеживание состояния конкретного файла в репозитории  
```$ git add .``` - отслеживание состояния всю текущую папку  

Состояние ```untracked``` - это значит, что Git ещё не хранит информацию о версиях файла и не может отследить, как он изменялся.  
Состояние ```modified``` - это значит, что Git уже хранит информацию о версиях файла, видит что файл был изменён, но файл ещё не сохранён.

## Делаем первый коммит  
Коммит — это одна из основных сущностей в Git (и в других системах контроля версий). Коммит гарантирует, что изменения будут сохранены в истории и при необходимости к ним можно будет «откатиться». Это как если бы вы могли выполнить операцию ```Ctrl+Z``` для целой папки (репозитория).  
### Выполнить коммит — git commit  
```$ git commit``` - команда выполняющая коммит = сохранение изменений  
```$ git commit -m "текст поясняющий вносимые изменения"``` - команда выполняющая коммит = сохранение изменений + добавляет поясняющий текст  
```$ git log``` - просмотр истории коммитов + !```git log``` выводит коммиты в обратном хронологическом порядке — последние коммиты оказываются первыми сверху

### Ещё раз о разнице между git add и git commit  
Сначала команда git add сообщает Git, какие именно файлы нужно сохранить и какую их версию. Затем с помощью команды git commit происходит само сохранение.  

## Знакомство с GitHub  
До этого момента вы использовали Git локально: сейчас проект ```first-project``` хранится только на вашем компьютере. Но одно из ключевых преимуществ Git — удобство командной работы над файлами. Чтобы поделиться репозиторием — например, с коллегами, — нужно завести его удалённую версию. Есть несколько платформ для такой командной работы. Самая популярная — GitHub. В нескольких следующих уроках покажем, как с ней работать.  

### Что такое GitHub  
GitHub — платформа для хранения IT-проектов и совместной работы над ними с использованием Git. По сути, это сайт, куда можно загрузить файлы своего проекта для обмена с другими людьми.  
GitHub подходит, чтобы отточить навыки работы с Git. Здесь можно завести аккаунт и вместе со своей командой работать над любыми задачами. Можно создавать проекты разных типов: 
- приватный — только для вас;
- командный — только для членов команды;
- публичный — будет виден всем.

### Git и платформы для удалённой работы  
Git и GitHub — это два разных проекта, которые развиваются независимо друг от друга.  
Git:
- консольный инструмент для работы с локальными и удалёнными репозиториями;
- проект с открытым исходным кодом.  
GitHub (аналоги: GitLab, Bitbucket):  
- платформа для размещения удалённых репозиториев;
- принадлежит компании Microsoft.  

## Регистрация на GitHub  
### Инструкция по регистрации  
1. В правом верхнем углу главной страницы GitHub нажмите на Sign up (англ. «зарегистрироваться»).  
2. На экране будут последовательно появляться поля для ввода.
2.1. Введите адрес электронной почты (англ. Enter your email).
2.2. Придумайте пароль (англ. Create a password).
2.3. Введите имя пользователя (англ. Enter a username).
3. Платформа спросит, хотите ли вы получать на почту рассылку с обновлениями и новостями (англ. Would you like to receive product updates and announcements via email?). Введите y, если хотите получать рассылку, или n, если не хотите.
4. Нажмите кнопку Continue (англ. «продолжить»).
5. GitHub предложит вам пройти капчу. Сделайте это.
6. После прохождения капчи нажмите Create account (англ. «создать аккаунт»).
7. Введите короткий код, который будет отправлен на указанный вами почтовый адрес.
   Ура!
   
## Создаём удалённый репозиторий  
### Инструкция по созданию репозитория на GitHub  
1. Зайдите в свой профиль по ссылке ```https://github.com/username```, где ```username``` — имя, которое вы указали при регистрации.
2. Создайте репозиторий. Для этого перейдите на вкладку **Repositories** (англ. «репозитории»), а затем нажмите на зелёную кнопку **New** (англ. «новый») справа.
3. Открылось окно создания нового репозитория. Назовите его ```first-project```. Название удалённого репозитория необязательно должно совпадать с именем папки проекта у вас на компьютере. Но чтобы не путаться, будем называть их одинаково. Другие поля вам пока не понадобятся. Смело нажимайте на зелёную кнопку **Create repository** (англ. «создать репозиторий») внизу.

Осталось связать удалённый репозиторий с локальным, который уже есть на вашем компьютере.  

## Что такое SSH. Генерируем SSH-ключ  
Чтобы получить доступ к репозиторию на GitHub, вам тоже нужно предоставить ключ, который подтверждает вашу личность и права на чтение или изменение данных. Без этого ключа доступ будет ограничен. Об этом и пойдёт речь в уроке.  
### Что такое SSH  
Когда компьютеры обмениваются данными в сети, они следуют сетевым протоколам — правилам обмена данными между компьютерами. Один из наиболее распространённых сетевых протоколов — **SSH** (от англ. Secure Shell Protocol). Он обеспечивает безопасный обмен данными в сети. С помощью этого протокола можно получать данные с удалённого компьютера или отправлять их на него. Трафик шифруется, поэтому протокол безопасен.  

**SSH** использует пару ключей для обеспечения безопасности — публичный и приватный:  
- **Приватный ключ** (англ. private key) хранится только на вашем компьютере и не должен передаваться кому-либо ещё. Он используется для расшифровки данных.
- **Публичный ключ** (англ. public key) доступен всем и используется для шифрования данных. Они могут быть расшифрованы парным приватным ключом.

Только вы можете расшифровать данные с помощью приватного ключа, но любой владелец публичного ключа может их для вас зашифровать. Эти два ключа связаны и образуют SSH-пару. В будущем вы наверняка будете использовать их для взаимодействия с GitHub и другими удалёнными серверами.  

### Проверка наличия SSH-ключа  
Прежде чем генерировать SSH-ключи, убедитесь, что у вас их ещё нет. По умолчанию директория с SSH-ключами находится в домашней директории пользователя. Обычно SSH-ключи находятся в директории ```.ssh/```.  

```$ ls -la .ssh/ # вывели список созданных ключей ```  

Если папка пустая или её нет, всё в порядке. Если есть файлы с похожими названиями, SSH-ключи уже создавались: ```id_dsa.pub```, ```id_ecdsa.pub```, ```id_ed25519.pub```, ```id_rsa.pub```. Если вы не создавали эти файлы, удалите их все.

### Инструкция по генерации SSH-ключа  
1. Для генерации SSH-пары можно использовать программу ```ssh-keygen```. Откройте терминал и введите следующую команду.

```$ ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"```

Используйте электронную почту, к которой привязан ваш GitHub-аккаунт.  
Если вы видите сообщение об ошибке, то, скорее всего, ваша система не поддерживает алгоритм шифрования ed25519. Ничего страшного: используйте другой алгоритм:

```$ ssh-keygen -t rsa -b 4096 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"```

  После ввода отобразится такое сообщение: ```> Generating public/private rsa key pair. # сгенерированы публичный и приватный ключи```.

2. Укажите место хранения ключей. Простой вариант — сделать домашний каталог пользователя путём по умолчанию. Для этого нажмите ```Enter```:
```> Enter a file in which to save the key (C:\Users\<имя_пользователя>\.ssh\):[Press enter] ```  
 Теперь в указанной директории появится пара ключей.

4. Программа запросит **кодовую фразу** (англ. passphrase) для доступа к SSH-ключу. Вы можете оставить поле пустым. Для этого нажмите ```Enter```, а затем ещё раз ```Enter``` для подтверждения.
5. Готово! Теперь осталось проверить, что ключи действительно сгенерировались. Для этого вызовите эту команду ```ls -a ~/.ssh```. На экране должны появиться два файла — один с расширением ```.pub```, другой — без. Файл в ```.pub``` — публичный, им можно делиться с веб-сайтами или коллегами. Файл без расширения ```.pub``` — приватный. Ни в коем случае не передавайте его никому!

## Привязываем SSH-ключ к GitHub  
### Инструкция по связыванию SSH-ключа и GitHub-аккаунта  
1. После выполнения команды ```ssh-keygen``` из предыдущего урока в директории ```~/.ssh``` будет создано два файла — ```id_ed25519``` и ```id_ed25519.pub``` (или ```id_rsa``` и ```id_rsa.pub``` — в зависимости от того, какой алгоритм вы использовали):
   - ```id_ed25519/id_rsa``` — приватный ключ (файл без ```.pub``` в конце). Ни в коем случае не копируйте его и не делитесь им.
   - ```id_ed25519.pub/id_rsa.pub``` — публичный ключ (на это указывает расширение ```.pub```). id_ed25519.pub/id_rsa.pub — публичный ключ (на это указывает расширение .pub).

```# скопировать содержимое ключа в буфер обмена:```  
```$ clip < ~/.ssh/id_rsa.pub```  
```# для ed25519:```  
```$ clip < ~/.ssh/id_ed25519.pub```  
Если ```clip``` не сработает, выведите содержимое файла с помощью ```cat ~/.ssh/id_rsa.pub``` или ```cat ~/.ssh/id_ed25519.pub``` и скопируйте вывод в буфер обмена из консоли.  

2. Перейдите на GitHub и выберите пункт **Settings** (англ. «настройки») в меню аккаунта.  
3. В меню слева нажмите на пункт **SSH and GPG keys**.
4. В открывшейся вкладке выберите **New SSH key** (англ. «новый SSH-ключ»).
5. В поле **Title** (англ. «заголовок») напишите название ключа. Например, **Personal key** (англ. «личный ключ»).
6. В поле **Key type** (англ. «тип ключа») должно быть **Authentication Key** (англ. «ключ аутентификации»).
7. В поле **Key** скопируйте ваш ключ из буфера обмена.
8. Нажмите на кнопку **Add SSH key** (англ. «добавить SSH-ключ»).
9. Проверьте правильность ключа с помощью следующей команды: ```$ ssh -T git@github.com```
    
   Если это первый раз, когда вы используете Git, чтобы поделиться проектом на GitHub, появится похожее предупреждение:  
   ```The authenticity of host 'github.com (140.82.121.4)' can't be established. ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU. This key is not known by any other names. Are you sure you want to continue connecting (yes/no/[fingerprint])?```  
   Это предупреждение сообщает, что вы никогда не соединялись с сервером GitHub. Поэтому Git не может гарантировать, что сервер является тем, за кого он себя выдаёт.
Для подтверждения подлинности сервер генерирует и публикует ключи SHA256.  
Вы можете проверить ключи [GitHub по этой ссылке](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints). Если ключ в предупреждении совпадает с тем, что вы видите на сайте, значит, сервер является действительным. Введите ```yes```, чтобы продолжить. Вы увидите приветствие на экране:
```Hi %ВАШ_АККАУНТ%! You've successfully authenticated, but GitHub does not provide shell access. ```

## Связываем локальный и удалённый репозитории  
### Привязать удалённый репозиторий к локальному — git remote add  
- Перейдите на страницу удалённого репозитория, выберите тип SSH и скопируйте URL. Кнопка справа позволит сделать это мгновенно.
- Откройте консоль, перейдите в каталог локального репозитория и введите команду ```git remote add``` (от англ. remote — «удалённый» и add — «добавить»).
  
```$ cd тут_указываем_путь_к_директории_в_которой_лежит_проект```
```$ git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git ```

```origin``` (англ. «источник») — стандартный псевдоним, с помощью которого можно обращаться к главному удалённому репозиторию (обычно такой репозиторий один). Это значительно упрощает работу.

### Убедиться, что репозитории связаны, — git remote -v
```$ git remote -v```  
```origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)```  
```origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push)```  

## Синхронизируем локальный и удалённый репозитории  
### Отправить изменения на удалённый репозиторий — git push  
Вы уже прошли весь «цикл коммита»: подготовили файлы с помощью ```git add```, закоммитили их с комментарием командой ```git commit -m```. Осталось загрузить содержимое локального репозитория на GitHub. За это отвечает команда ```git push``` (от англ. push — «толкать»).

В первый раз эту команду нужно вызвать с флагом ```-u``` и параметрами ```origin``` (имя удалённого репозитория) и ```main``` или ```master``` (название текущей ветки). Флаг ```-u``` свяжет локальную ветку с одноимённой удалённой. Как вы связывали локальный и удалённый репозитории в предыдущем уроке, так же и здесь нужно дополнительно связать ветки.

```$ git push -u origin main # Если команда приведёт к ошибке, попробуйте заменить main на master.s```  

При взаимодействии с удалёнными репозиториями Git выводит в консоль отладочную информацию: количество объектов (файлов), которые отправляются на сервер, информацию о прогрессе сжатия и записи и так далее.  
Зайдите в репозиторий ```first-project на GitHub```. Вы увидите, что в репозитории появились файлы с изменениями.  
В дальнейшем при работе с удалённым репозиторием флаг -u можно опустить и писать просто ```git push```.  

## Хеш — идентификатор коммита  
- Хеш — основной идентификатор коммита и позволяет узнать его автора, дату и содержимое закоммиченных файлов.  
- Все хеши, а также таблицу соответствий ```хеш → информация о коммите``` Git хранит в папке ```.git```.
- Git преобразует информацию о коммитах с помощью алгоритма SHA-1 и для каждого из них рассчитывает уникальный идентификатор — хеш.

## Тут будет перечислен список базовых команд GIT

```git init``` - инициализирует новый репозиторий (для этого, нужно зайти в папку, которую мы хотим сделать репозиторием и запустить в ней команду ```git init```)  
```git add``` - команда добавляет в staging area только текущее содержимое файла (если выполнить ```git add```, а потом изменить файл, то новые изменения в staging area не попадут)  
```git status``` - показывает статусы файлов в директории
```git commit -m "Добавить урок про оформление сообщений коммитов"``` - команда, которая заливает изменения репозиторий + добавляет комментарий, о чём эти изменения (72 символа)

**в итоге git status показывает только следующие состояния файлов:**  
- ```staged``` (```Changes to be committed``` в выводе ```git status```);
- ```modified``` (```Changes not staged for commit```);
- ```untracked``` (```Untracked files```).

## Работа с логами

```git log``` - показывает историю коммитов  
```git log --oneline``` - получить сокращённый лог  
```q``` - команда для выхода из лога (если автоматического выхода не произошло)

## Статусы файлов в GIT: ```untracked```/```tracked```, ```staged``` и ```modified```  
- ```untracked``` - неотслеживаемый - новые файлы в Git-репозитории помечаются как ```untracked```, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём
- ```staged```/```indexed```/```cached```  - подготовленный - после выполнения команды ```git add``` файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии ```staged```
- ```tracked```- отслеживаемый - все файлы, в которых Git так или иначе отслеживает изменения
- ```modified```- изменённый - cостояние ```modified``` означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

Для файлов в состояниях ```staged``` и ```modified``` обычно не указывают, что они также ```tracked```, потому что это состояние подразумевается.

<img width="2880" height="1260" alt="Image" src="https://github.com/user-attachments/assets/1bc5f51b-eece-4fc6-8e5a-1af5b3be8e8d" />

## Дополнительная полезная информация  
### HEAD файл  
```HEAD``` - файл ```Head``` один из служебных файлов папки ```.git.``` Он указывает на коммит, который сделан последним (то есть на самый новый). Внутри ```HEAD``` — ссылка на служебный файл: ```refs/heads/master``` (или ```refs/heads/main``` в зависимости от названия ветки). В этом файле, можно увидеть хеш последнего коммита.

## Оформление сообщений к коммитам    
Есть общие рекомендации по тому, как правильно составить сообщение. Оно должно быть:
- относительно коротким, чтобы его было легко прочитать;
- информативным.  

Стандарт **Conventional Commits** (англ. «соглашение о коммитах») отличается качественной документацией и подробной проработкой. Он подходит для репозиториев с исходным кодом программ. **Conventional Commits** предлагает такой формат коммита: ```<type>: <сообщение>```. Первая часть ```type``` — это тип изменений. Таких типов достаточно много. Вот два примера:
- ```feat``` (сокращение от англ. feature) — для новой функциональности;
- ```fix``` (от англ. «исправить», «устранить») — для исправленных ошибок.

## Как исправить коммит  
```git commit --amend``` - команда, которая позволяет внести правки в уже сделанный коммит  

**Важно:**  
- опция ```--amend``` работает только с последним коммитом (HEAD). Для исправления более ранних коммитов есть другие команды.  
- c опцией ```--amend``` команда ```commit``` не создаст новый коммит, а дополнит последний, просто добавив новые файлы (пропущенные).  

- ```git commit --amend --no-edit``` - опция ```--no-edit``` сообщает команде ```commit```, что сообщение коммита нужно оставить как было  
- ```git commit --amend -m "Новое сообщение"``` - команда для изменения сообщение коммита  

## Как откатиться назад, если «всё сломалось»   
```git restore --staged <file>``` - команда переведёт файл из ```staged```(списка на коммит) обратно в ```modified``` или ```untracked```  
```git restore --staged .``` - сбросит всю текущую папку из staged  
```git reset --hard <commit hash>``` - иногда нужно «откатить» то, что уже было закоммичено, то есть вернуть состояние репозитория к более раннему - по сути удаляет эти изменения (в ```commit hash``` нужно указать хэш того коммита, на который нужно откатиться)
```git restore <file>``` - команда «откатит» изменения в файле до последней сохранённой (в коммите или в staging) версии  

<img width="2902" height="2368" alt="image" src="https://github.com/user-attachments/assets/b20b7faa-022d-4549-b80e-454d342df240" />

## Просматриваем изменения в файлах  
```git diff``` - показывает изменения, которые не были добавлены в ```staged```  
```git diff --staged``` - показывает, что изменилось в проиндексированных файлах  
```git diff номер_хэша_от_которого_хотим_смотреть  номер_хэша_до_которого_хотим_смотреть``` - показывает какие именно данные были изменены при коммите  
- красный цвет строки означает, что эта строка была удалена  
- зелёный цвет строки означает, что она была добавлена  

**Важно: Порядок аргументов***
По сути команда ```git diff A B``` выводит список инструкций: как превратить состояние ```A``` в состояние ```B```. Если поменять ```A``` и ```B``` местами (```git diff B A```), то и инструкции будут обратные: как превратить ```B``` в ```A```. При этом все зелёные строки станут красными, и наоборот.

**Пример:**  
Строка ```@@ -1,2 +1,2 @@```  - сообщает, какие строки файла попали в сравнение. Выражение ````1,2``` (неважно, с плюсом или с минусом) говорит, что были использованы две строки, начиная с первой. Если бы было, например, написано ```+15,7```, это значило бы, что в сравнении участвуют 7 строк, начиная с 15-й.  
Выражение со знаком минус (```-1,2```) относится к «оригинальной» версии файла (```a/teremok.txt```), а со знаком плюс (```+1,2```) — к «изменённой» (```b/teremok.txt```).

## Игнорирование файлов в Git  
```.gitignore``` - файл, в котором записывается список игнорируемых файлов  

С точки зрения Git ```.gitignore``` — это обычный текстовый файл. Его добавляют в корень репозитория и тоже коммитят.  

В простейшем случае в ```.gitignore``` указывают все файлы, которые нужно игнорировать (по одному имени на строку). Но часто удобнее использовать шаблоны. Шаблон, или правило, — это способ указать сразу на несколько файлов с однотипными названиями.  

**Важно:** Правила из ```.gitignore``` применяются только к новым (```untracked```) файлам. Если файл уже попал в staging area или в коммит, то правила на него не распространяются.  

- Если строка начинается с ```#```, то это комментарий, и ```.gitignore``` не будет его учитывать.
- Допустим, нужно, чтобы Git игнорировал все файлы ```.DS_Store```. Для этого достаточно добавить в ```.gitignore``` строку с названием файла (в таком случае Git будет игнорировать файлы с именем ```.DS_Store```, причём не только в корне репозитория, но и во всех вложенных папках)
- Символ звёздочки (```*```) соответствует любой строке, включая пустую. Если такой символ используется в шаблоне в ```.gitignore```, значит, файл будет проигнорирован вне зависимости от того, что будет на месте звёздочки  
- Вопросительный знак ```?``` соответствует одному любому символу
- Квадратные скобки ```[…]```, как и вопросительный знак, соответствуют одному символу. При этом символ не любой, а только из списка, который указан в скобках  
- Косая черта, или слеш (```/```), указывает на каталоги. Если шаблон в ```.gitignore``` начинается со слеша, то Git проигнорирует файлы или каталоги только в корневой директории. Если шаблон заканчивается слешем, то правило применится только к папке.  
- Функция парных звёздочек (```**```) похожа на функцию одинарной (*). Отличие в том, как они работают с вложенными папками. Двойная звёздочка может соответствовать любому количеству таких папок (в том числе нулю). Одинарная может соответствовать только одной.
- Любое правило в файле ```.gitignore``` можно инвертировать с помощью восклицательного знака (```!```)

**Важно:** Игнорируемые файлы не отображаются в выводе команды git status, иначе они бы засоряли вывод. Если всё же нужно отобразить все игнорируемые файлы, то это можно сделать с помощью ключа ```--ignored: git status --ignored```. В таком случае в выводе ```git status``` появится раздел ```Ignored files```.

# Основы работы с ветками GIT  
## Клонируем репозиторий  
```git clone``` - клонирование репозитория — обычно первое, что делает разработчик на новом месте работы  
- Команда ```git clone``` копирует проект на локальный компьютер.
- ```git clone``` автоматически связывает локальный репозиторий с удалённым.

## Выполняем Fork  
### Что такое Fork
***Fork*** (англ. «развилка», «ответвление»), или ***«форк»***, — это GitHub-операция; напрямую с Git она не связана. «Форк» создаёт копию репозитория в аккаунте GitHub. Такая копия будет полностью независима. Изменения, которые вы внесёте, не будут синхронизированы с исходным репозиторием.

## Что такое ветка  
**Ветка** (англ. branch) — это изолированный поток разработки проекта. В таком потоке можно проверять разные идеи, тестировать новую функциональность и так далее.  
```git branch``` - просмотреть ветки проекта.  
### Создаём ветку  
```git branch <название_ветки>``` - создание ветки  

